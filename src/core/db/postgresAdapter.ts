import type { DBAdapter, FindFilter, Pagination, Sort } from "./dbAdapter";
import type { NormalizedSchema } from "../schemaLoader";

type PgPool = any;

export class PostgresAdapter implements DBAdapter {
  private url: string;
  private pool: PgPool | null = null;
  private initialized: Set<string> = new Set();

  constructor(url: string) {
    this.url = url;
  }

  async connect() {
    const mod = await import("pg");
    const { Pool } = (mod as any);
    this.pool = new Pool({ connectionString: this.url });
    // Simple connectivity check
    await this.pool.query("SELECT 1");
  }

  async disconnect() {
    if (this.pool) await this.pool.end();
    this.pool = null;
    this.initialized.clear();
  }

  private ensurePool() {
    if (!this.pool) throw new Error("DB_ERROR: Postgres not connected");
    return this.pool;
  }

  private sqlType(t: string): string {
    switch (t) {
      case "string":
        return "text";
      case "number":
        return "double precision";
      case "boolean":
        return "boolean";
      case "date":
        return "timestamptz";
      case "json":
        return "jsonb";
      default:
        return "text";
    }
  }

  private async ensureTable(schema: NormalizedSchema) {
    if (this.initialized.has(schema.name)) return;
    const pool = this.ensurePool();
    const cols: string[] = [];
    for (const [name, def] of Object.entries(schema.fields)) {
      if (name === schema.primaryKey && schema.pk.strategy === "sequence" && def.type === "number") {
        cols.push(`"${name}" bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY`);
      } else {
        const base = `"${name}" ${this.sqlType(def.type)}`;
        if (name === schema.primaryKey) cols.push(`${base} PRIMARY KEY`);
        else cols.push(base);
      }
    }
    const sql = `CREATE TABLE IF NOT EXISTS "${schema.name}" (${cols.join(", ")})`;
    await pool.query(sql);
    this.initialized.add(schema.name);
  }

  private buildWhere(schema: NormalizedSchema, filter?: FindFilter) {
    if (!filter || Object.keys(filter).length === 0) return { clause: "", params: [] as any[] };
    const parts: string[] = [];
    const params: any[] = [];
    let idx = 1;
    for (const [k, v] of Object.entries(filter)) {
      if (v && typeof v === "object" && !Array.isArray(v)) {
        for (const [op, ov] of Object.entries<any>(v)) {
          switch (op) {
            case "eq":
              parts.push(`"${k}" = $${idx++}`);
              params.push(ov);
              break;
            case "in":
              if (!Array.isArray(ov) || ov.length === 0) {
                parts.push("FALSE");
              } else {
                const ph = ov.map(() => `$${idx++}`).join(",");
                parts.push(`"${k}" IN (${ph})`);
                params.push(...ov);
              }
              break;
            case "gt":
              parts.push(`"${k}" > $${idx++}`);
              params.push(ov);
              break;
            case "gte":
              parts.push(`"${k}" >= $${idx++}`);
              params.push(ov);
              break;
            case "lt":
              parts.push(`"${k}" < $${idx++}`);
              params.push(ov);
              break;
            case "lte":
              parts.push(`"${k}" <= $${idx++}`);
              params.push(ov);
              break;
            case "contains":
              parts.push(`"${k}" LIKE $${idx++}`);
              params.push(`%${ov}%`);
              break;
            default:
              break;
          }
        }
      } else {
        parts.push(`"${k}" = $${idx++}`);
        params.push(v);
      }
    }
    const clause = parts.length ? `WHERE ${parts.join(" AND ")}` : "";
    return { clause, params };
  }

  private fromDbRow(schema: NormalizedSchema, row: any) {
    if (!row) return row;
    const out: any = { ...row };
    for (const [field, def] of Object.entries(schema.fields)) {
      const v = out[field];
      if (v === null || v === undefined) continue;
      if (def.type === "boolean") out[field] = v === true || v === 1;
      if (def.type === "date") out[field] = typeof v === "string" ? v : new Date(v).toISOString();
    }
    return out;
  }

  async find(schema: NormalizedSchema, opts: { filter?: FindFilter; pagination?: Pagination; sort?: Sort }): Promise<any[]> {
    await this.ensureTable(schema);
    const pool = this.ensurePool();
    const { clause, params } = this.buildWhere(schema, opts.filter);
    const order = opts.sort?.field ? `ORDER BY "${opts.sort.field}" ${opts.sort?.direction === "desc" ? "DESC" : "ASC"}` : "";
    const limit = opts.pagination?.limit ?? 50;
    const offset = opts.pagination?.offset ?? 0;
    const sql = `SELECT * FROM "${schema.name}" ${clause} ${order} LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    const result = await pool.query(sql, [...params, limit, offset]);
    return result.rows.map((r: any) => this.fromDbRow(schema, r));
  }

  async findById(schema: NormalizedSchema, id: any): Promise<any | null> {
    await this.ensureTable(schema);
    const pool = this.ensurePool();
    const sql = `SELECT * FROM "${schema.name}" WHERE "${schema.primaryKey}" = $1`;
    const result = await pool.query(sql, [id]);
    return result.rows[0] ? this.fromDbRow(schema, result.rows[0]) : null;
  }

  async insert(schema: NormalizedSchema, doc: any): Promise<any> {
    await this.ensureTable(schema);
    const pool = this.ensurePool();
    let fields = Object.keys(schema.fields);
    const now = new Date().toISOString();
    if (schema.pk.strategy === "sequence" && doc[schema.primaryKey] === undefined) {
      fields = fields.filter((f) => f !== schema.primaryKey);
    }
    const values = fields.map((f) => (f === "createdAt" || f === "updatedAt") && schema.timestamps ? now : (doc as any)[f]);
    const cols = fields.map((f) => `"${f}"`).join(", ");
    const placeholders = fields.map((_, i) => `$${i + 1}`).join(", ");
    const sql = `INSERT INTO "${schema.name}" (${cols}) VALUES (${placeholders}) RETURNING *`;
    const result = await pool.query(sql, values);
    return this.fromDbRow(schema, result.rows[0]);
  }

  async update(schema: NormalizedSchema, id: any, patch: any): Promise<any | null> {
    await this.ensureTable(schema);
    const pool = this.ensurePool();
    // Merge patch on read to keep unspecified columns
    const existing = await this.findById(schema, id);
    if (!existing) return null;
    const updated: any = { ...existing, ...patch };
    if (schema.timestamps) updated.updatedAt = new Date().toISOString();
    const fields = Object.keys(schema.fields).filter((f) => f !== schema.primaryKey);
    const set = fields.map((f, i) => `"${f}" = $${i + 1}`).join(", ");
    const params = fields.map((f) => updated[f]);
    const sql = `UPDATE "${schema.name}" SET ${set} WHERE "${schema.primaryKey}" = $${fields.length + 1} RETURNING *`;
    const result = await pool.query(sql, [...params, id]);
    return result.rows[0] ? this.fromDbRow(schema, result.rows[0]) : null;
  }

  async delete(schema: NormalizedSchema, id: any): Promise<boolean> {
    await this.ensureTable(schema);
    const pool = this.ensurePool();
    const sql = `DELETE FROM "${schema.name}" WHERE "${schema.primaryKey}" = $1`;
    const result = await pool.query(sql, [id]);
    return (result.rowCount ?? 0) > 0;
  }
}
